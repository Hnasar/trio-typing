[case testSmoke]
import trio
import trio.testing
from typing import List, Sequence

async def sleep_sort(values: Sequence[float]) -> List[float]:
    result: List[float] = []

    async def worker(value: float) -> None:
        await trio.sleep(value)
        result.append(value)

    async with trio.open_nursery() as nursery:
        reveal_type(nursery)  # E: Revealed type is 'trio_typing.Nursery*'
        reveal_type(nursery.cancel_scope)  # E: Revealed type is 'trio_typing.CancelScope'
        for value in values:
            nursery.start_soon(worker, value)
            nursery.start_soon(worker)  # E: Argument 1 to "start_soon" of "Nursery" has incompatible type "Callable[[float], Coroutine[Any, Any, None]]"; expected "Callable[[], Awaitable[None]]"
            nursery.start_soon(worker, "hi")  # E: Argument 1 to "start_soon" of "Nursery" has incompatible type "Callable[[float], Coroutine[Any, Any, None]]"; expected "Callable[[str], Awaitable[None]]"
            nursery.start_soon(worker, value, value)  # E: Argument 1 to "start_soon" of "Nursery" has incompatible type "Callable[[float], Coroutine[Any, Any, None]]"; expected "Callable[[float, float], Awaitable[None]]"

    return result

trio.run(sleep_sort, (1, 3, 5, 2, 4), clock=trio.testing.MockClock(autojump_threshold=0))
trio.run(sleep_sort, ["hi", "there"])  # E: Argument 1 to "run" has incompatible type "Callable[[Sequence[float]], Coroutine[Any, Any, List[float]]]"; expected "Callable[[List[str]], Awaitable[List[float]]]"
[out]

[case testAsyncCM]
import trio
from typing import AsyncIterator
from trio_typing import Nursery
from async_generator import asynccontextmanager

@asynccontextmanager
async def open_nursery_cancel_in(seconds: float) -> AsyncIterator[Nursery]:
    async with trio.open_nursery() as nursery:
        nursery.cancel_scope.deadline = trio.current_time() + seconds
        yield nursery

async def test() -> None:
    async with open_nursery_cancel_in(3) as nursery:
        reveal_type(nursery)  # E: Revealed type is 'trio_typing.Nursery*'
    async with open_nursery_cancel_in(None):  # E: Argument 1 to "open_nursery_cancel_in" has incompatible type "None"; expected "float"
        pass
[out]

[case testTaskStatus]
import trio
from trio_typing import TaskStatus

async def child(arg: int, *, task_status: TaskStatus[int]) -> None:
    await trio.sleep(arg)
    task_status.started("hi")  # E: Argument 1 to "started" of "TaskStatus" has incompatible type "str"; expected "int"
    task_status.started()  # E: TaskStatus.started() requires an argument for types other than TaskStatus[None]

async def child2(arg: int, *, task_status: TaskStatus[None]) -> None:
    await trio.sleep(arg)
    task_status.started()

async def parent() -> None:
    async with trio.open_nursery() as nursery:
        result = await nursery.start(child, 10)
        result2 = await nursery.start(child2, 10)
        reveal_type(result)  # E: Revealed type is 'builtins.int*'
        reveal_type(result2)  # E: Revealed type is 'None'

[out]

[case testAsyncGenerator]
from typing import Tuple, Union, Generic, TypeVar, AsyncIterator, cast
from async_generator import async_generator, yield_, yield_from_
from trio_typing import YieldType, SendType

T = TypeVar("T")

class arange(Generic[T]):
    def __aiter__(self) -> "arange[T]":
        return self
    async def __anext__(self) -> T:
        return cast(T, 0)

@async_generator
async def test_agen(x: int, y: str) -> Union[
    str, YieldType[Tuple[int, int]], SendType[float]
]:
    v1 = await yield_()  # E: Incompatible types (yield_ argument "None", declared YieldType "Tuple[int, int]")
    reveal_type(v1)  # E: Revealed type is 'builtins.float*'
    v2 = await yield_(3)  # E: Incompatible types (yield_ argument "int", declared YieldType "Tuple[int, int]")
    reveal_type(v2)  # E: Revealed type is 'builtins.float*'
    v3 = await yield_((4, 5))
    reveal_type(v3)  # E: Revealed type is 'builtins.float*'
    await yield_from_(arange[float]())  # E: Incompatible types (yield_from_ argument type "arange[float]", expected iterable type "AsyncIterable[Tuple[int, int]]")
    await yield_from_(arange[Tuple[int, int]]())
    await yield_from_(arange[Tuple[bool, int]]())
    await yield_from_(arange[Tuple[int, float]]())  # E: Incompatible types (yield_from_ argument type "arange[Tuple[int, float]]", expected iterable type "AsyncIterable[Tuple[int, int]]")
    if x > 0:
        yf_res = await yield_from_(test_agen(x - 1, y + "yo"))
        reveal_type(yf_res)  # E: Revealed type is 'builtins.str*'
        return yf_res
    else:
        return y

async def test() -> None:
    ag_bad = test_agen()  # E: Too few arguments for "test_agen"
    reveal_type(ag_bad)  # E: Revealed type is 'trio_typing.AsyncGeneratorWithReturn[Tuple[builtins.int, builtins.int], builtins.float, builtins.str]'
    test_agen("one", "two")  # E: Argument 1 to "test_agen" has incompatible type "str"; expected "int"
    agen = test_agen(1, "two")
    reveal_type(agen)  # E: Revealed type is 'trio_typing.AsyncGeneratorWithReturn[Tuple[builtins.int, builtins.int], builtins.float, builtins.str]'
    v1 = await agen.__anext__()
    reveal_type(v1)  # E: Revealed type is 'Tuple[builtins.int, builtins.int]'
    v2 = await agen.asend(3.2)
    reveal_type(v2)  # E: Revealed type is 'Tuple[builtins.int, builtins.int]'
    v3 = await agen.asend(None)  # E: Argument 1 to "asend" of "AsyncGenerator" has incompatible type "None"; expected "float"
    reveal_type(v3)  # E: Revealed type is 'Tuple[builtins.int, builtins.int]'

[out]

[case testPartial]
import functools
import mypy_extensions
from typing import Tuple

def fn(__arg1: int, arg2: str, arg3: bool = False, *args, arg4: str, arg5: int = 42):
    pass

pfn = functools.partial(fn, 2, "wat", arg3=True, arg5=10)
reveal_type(pfn)
reveal_type(pfn.args)
reveal_type(pfn.keywords)
reveal_type(pfn.func)
pfn(False, object(), arg4="there")

def test(args: Tuple[int, str], args2: Tuple[int, ...]):
    pfn3 = functools.partial(fn, *args, *args2)
    reveal_type(pfn3)
    reveal_type(pfn3.args)
    reveal_type(pfn3.keywords)
    reveal_type(pfn3.func)

elems = [1, 2, 3]
kwds = {"a": 4, "b": 5}
pfn2 = functools.partial(fn, 0, *elems, c=4, **kwds)
reveal_type(pfn2)
reveal_type(pfn2.args)
reveal_type(pfn2.keywords)
reveal_type(pfn2.func)

[out]
